        -:    0:Source:schedule.c
        -:    0:Graph:schedule.gcno
        -:    0:Data:schedule.gcda
        -:    0:Runs:2650
        -:    1:#include <stdio.h>
        -:    2:#include <signal.h>
        -:    3:
        -:    4:#define NULL 0
        -:    5:
        -:    6:#define NEW_JOB        1
        -:    7:#define UPGRADE_PRIO   2 
        -:    8:#define BLOCK          3
        -:    9:#define UNBLOCK        4  
        -:   10:#define QUANTUM_EXPIRE 5
        -:   11:#define FINISH         6
        -:   12:#define FLUSH          7
        -:   13:
        -:   14:#define MAXPRIO 3
        -:   15:
        -:   16:FILE* file_name = NULL;
        -:   17:
        -:   18:// Signal handler for SIGSEGV 
        -:   19:// add by mshadow
       41:   20:void segfault_handler(int sig) {
       41:   21:    exit(sig);  // Exit the program
        -:   22:}
        -:   23:
        -:   24:typedef struct _job {
        -:   25:    struct  _job *next, *prev; /* Next and Previous in job list. */
        -:   26:    int          val  ;         /* Id-value of program. */
        -:   27:    short        priority;     /* Its priority. */
        -:   28:} Ele, *Ele_Ptr;
        -:   29:
        -:   30:typedef struct list		/* doubly linked list */
        -:   31:{
        -:   32:    Ele *first;
        -:   33:    Ele *last;
        -:   34:    int    mem_count;		/* member count */
        -:   35:} List;
        -:   36:
    40332:   37:Ele* new_ele(new_num) 
        -:   38:int new_num;
        -:   39:{
    40332:   40:    fprintf(file_name,"P20,");	
        -:   41:    Ele *ele;
    40332:   42:    ele =(Ele *)malloc(sizeof(Ele));
    40332:   43:    ele->next = NULL;
    40332:   44:    ele->prev = NULL;
    40332:   45:    ele->val  = new_num;
    40332:   46:    return ele;
        -:   47:}
        -:   48:
     9647:   49:List *new_list()
        -:   50:{
     9647:   51:    fprintf(file_name,"P21,");
        -:   52:    List *list;
     9647:   53:    list = (List *)malloc(sizeof(List));
     9647:   54:    list->first = NULL;
     9647:   55:    list->last  = NULL;
     9647:   56:    list->mem_count = 0;
     9647:   57:    return (list);
        -:   58:}
        -:   59:
    60982:   60:List *append_ele(a_list, a_ele)
        -:   61:List *a_list;
        -:   62:Ele  *a_ele;
        -:   63:{
    60982:   64:    fprintf(file_name,"P22,");
    60982:   65:    if (!a_list)
        -:   66:    {
     1787:   67:        fprintf(file_name,"P23,");
     1787:   68:        a_list = new_list();	/* make list without compare function */
        -:   69:    }
        -:   70:
    60982:   71:    a_ele->prev = a_list->last;	/* insert at the tail */
    60982:   72:    fprintf(file_name,"P24,");
    60982:   73:    if (a_list->last)
        -:   74:    {
    33826:   75:        fprintf(file_name,"P25,");
    33826:   76:        a_list->last->next = a_ele;
        -:   77:    }
        -:   78:    else
        -:   79:    {
    27156:   80:        fprintf(file_name,"P26,");
    27156:   81:        a_list->first = a_ele;
        -:   82:    }
    60982:   83:    fprintf(file_name,"P27,");
    60982:   84:    a_list->last = a_ele;
    60982:   85:    a_ele->next = NULL;
    60982:   86:    a_list->mem_count++;
    60982:   87:    return (a_list);
        -:   88:}
        -:   89:
    12401:   90:Ele *find_nth(f_list, n)
        -:   91:List *f_list;
        -:   92:int   n;
        -:   93:{
        -:   94:    Ele *f_ele;
        -:   95:    int i;
    12401:   96:    fprintf(file_name,"P28,");
    12401:   97:    if (!f_list)
        -:   98:    {
    #####:   99:        fprintf(file_name,"P29,");
    #####:  100:        return NULL;
        -:  101:    }
        -:  102:
    12401:  103:    f_ele = f_list->first;
    12401:  104:    fprintf(file_name,"P30,");
    17043:  105:    for (i=1; f_ele && (i<n); i++)
        -:  106:    {
     4642:  107:        fprintf(file_name,"P31,");
     4642:  108:        f_ele = f_ele->next;
        -:  109:    }
    12401:  110:    fprintf(file_name,"P32,");
    12401:  111:    return f_ele;
        -:  112:}
        -:  113:
    51763:  114:List *del_ele(d_list, d_ele)
        -:  115:List *d_list;
        -:  116:Ele  *d_ele;
        -:  117:{
    51763:  118:    fprintf(file_name,"P33,");
    51763:  119:    if (!d_list || !d_ele)
        -:  120:    {
       41:  121:        fprintf(file_name,"P34,");
       41:  122:        return (NULL);
        -:  123:    }
        -:  124:    
    51722:  125:    fprintf(file_name,"P35,");
    51722:  126:    if (d_ele->next)
        -:  127:    {
    26814:  128:        fprintf(file_name,"P36,");
    26814:  129:        d_ele->next->prev = d_ele->prev;
        -:  130:    }
        -:  131:    else
        -:  132:    {
    24908:  133:        fprintf(file_name,"P37,");
    24908:  134:        d_list->last = d_ele->prev;
        -:  135:    }
        -:  136:
    51722:  137:    fprintf(file_name,"P38,");
    51722:  138:    if (d_ele->prev)
        -:  139:    {
     2403:  140:        fprintf(file_name,"P39,");
     2403:  141:        d_ele->prev->next = d_ele->next;
        -:  142:    }
        -:  143:    else
        -:  144:    {
    49319:  145:        fprintf(file_name,"P40,");
    49319:  146:        d_list->first = d_ele->next;
        -:  147:    }
    51722:  148:    fprintf(file_name,"P41,");
        -:  149:    /* KEEP d_ele's data & pointers intact!! */
    51722:  150:    d_list->mem_count--;
    51722:  151:    return (d_list);
        -:  152:}
        -:  153:
    31072:  154:void free_ele(ptr)
        -:  155:Ele *ptr;
        -:  156:{
    31072:  157:    fprintf(file_name,"P42,");
    31072:  158:    free(ptr);
    31072:  159:}
        -:  160:
        -:  161:int alloc_proc_num;
        -:  162:int num_processes;
        -:  163:Ele* cur_proc;
        -:  164:List *prio_queue[MAXPRIO+1]; 	/* 0th element unused */
        -:  165:List *block_queue;
        -:  166:
        -:  167:void
    41685:  168:finish_process()
        -:  169:{
    41685:  170:    schedule();
    41685:  171:    fprintf(file_name,"P43,");
    41685:  172:    if (cur_proc)
        -:  173:    {
    31072:  174:        fprintf(file_name,"P44,");
    31072:  175:        fprintf(stdout, "%d ", cur_proc->val);
    31072:  176:        free_ele(cur_proc);
    31072:  177:        num_processes--;
        -:  178:    }
    41685:  179:}
        -:  180:
        -:  181:void
    10763:  182:finish_all_processes()
        -:  183:{
        -:  184:    int i;
        -:  185:    int total;
    10763:  186:    total = num_processes;
    10763:  187:    fprintf(file_name,"P45,");
    44424:  188:    for (i=0; i<total; i++)
        -:  189:    {
    33661:  190:        fprintf(file_name,"P46,");
    33661:  191:        finish_process();
        -:  192:    }
    10763:  193:}
        -:  194:
    65319:  195:schedule()
        -:  196:{
        -:  197:    int i;
    65319:  198:    cur_proc = NULL;
    65319:  199:    fprintf(file_name,"P47,");
   166095:  200:    for (i=MAXPRIO; i > 0; i--)
        -:  201:    {
   144413:  202:        fprintf(file_name,"P48,");
   144413:  203:        if (prio_queue[i]->mem_count > 0)
        -:  204:        {
    43637:  205:            fprintf(file_name,"P49,");
    43637:  206:            cur_proc = prio_queue[i]->first;
    43637:  207:            prio_queue[i] = del_ele(prio_queue[i], cur_proc);
    43637:  208:            return;
        -:  209:        }
        -:  210:    }
        -:  211:}
        -:  212:
        -:  213:void
    11637:  214:upgrade_process_prio(prio, ratio)
        -:  215:int prio;
        -:  216:float ratio;
        -:  217:{
        -:  218:    int count;
        -:  219:    int n;
        -:  220:    Ele *proc;
        -:  221:    List *src_queue, *dest_queue;
    11637:  222:    fprintf(file_name,"P50,");
    11637:  223:    if (prio >= MAXPRIO)
        -:  224:    {
      853:  225:        fprintf(file_name,"P51,");
      853:  226:        return;
        -:  227:    }
        -:  228:	    
    10784:  229:    src_queue = prio_queue[prio];
    10784:  230:    dest_queue = prio_queue[prio+1];
    10784:  231:    count = src_queue->mem_count;
        -:  232:
    10784:  233:    fprintf(file_name,"P52,");
    10784:  234:    if (count > 0)
        -:  235:    {
     3367:  236:        n = (int) (count*ratio + 1);
     3367:  237:        proc = find_nth(src_queue, n);
     3367:  238:        fprintf(file_name,"P53,");
        -:  239:		/* if (proc) { */
     3367:  240:            src_queue = del_ele(src_queue, proc);
        -:  241:            /* append to appropriate prio queue */
     3367:  242:            proc->priority = prio;
     3367:  243:            dest_queue = append_ele(dest_queue, proc);
        -:  244:    	/* }  missing conditional check */
        -:  245:    }
        -:  246:}
        -:  247:
        -:  248:void
    12344:  249:unblock_process(ratio)
        -:  250:float ratio;
        -:  251:{
        -:  252:    int count;
        -:  253:    int n;
        -:  254:    Ele *proc;
        -:  255:    int prio;
    12344:  256:    fprintf(file_name,"P55,");
    12344:  257:    if (block_queue)
        -:  258:    {
     9034:  259:        count = block_queue->mem_count;
     9034:  260:        n = (int) (count*ratio + 1);
     9034:  261:        proc = find_nth(block_queue, n);
     9034:  262:        fprintf(file_name,"P56,");
     9034:  263:        if (proc) 
        -:  264:        {
     4759:  265:            fprintf(file_name,"P57,");
     4759:  266:            block_queue = del_ele(block_queue, proc);
        -:  267:            /* append to appropriate prio queue */
     4759:  268:            prio = proc->priority;
     4759:  269:            prio_queue[prio] = append_ele(prio_queue[prio], proc);
        -:  270:        }
        -:  271:    }
    12344:  272:}
        -:  273:
    11690:  274:void quantum_expire()
        -:  275:{
        -:  276:    int prio;
    11690:  277:    schedule();
    11690:  278:    fprintf(file_name,"P58,");
    11690:  279:    if (cur_proc)
        -:  280:    {
     6228:  281:        fprintf(file_name,"P59,");
     6228:  282:        prio = cur_proc->priority;
     6228:  283:        prio_queue[prio] = append_ele(prio_queue[prio], cur_proc);
        -:  284:    }	
    11690:  285:}
        -:  286:	
        -:  287:void
    11944:  288:block_process()
        -:  289:{
    11944:  290:    schedule();
    11944:  291:    fprintf(file_name,"P60,");
    11944:  292:    if (cur_proc)
        -:  293:    {
     6337:  294:        fprintf(file_name,"P61,");
     6337:  295:	    block_queue = append_ele(block_queue, cur_proc);
        -:  296:    }
    11944:  297:}
        -:  298:
    40332:  299:Ele * new_process(prio)
        -:  300:int prio;
        -:  301:{
    40332:  302:    fprintf(file_name,"P62,");
        -:  303:    Ele *proc;
    40332:  304:    proc = new_ele(alloc_proc_num++);
    40332:  305:    proc->priority = prio;
    40332:  306:    num_processes++;
    40332:  307:    return proc;
        -:  308:}
        -:  309:
    12799:  310:void add_process(prio)
        -:  311:int prio;
        -:  312:{
    12799:  313:    fprintf(file_name,"P63,");
        -:  314:    Ele *proc;
    12799:  315:    proc = new_process(prio);
    12799:  316:    prio_queue[prio] = append_ele(prio_queue[prio], proc);
    12799:  317:}
        -:  318:
     7860:  319:void init_prio_queue(prio, num_proc)
        -:  320:int prio;
        -:  321:int num_proc;
        -:  322:{
        -:  323:    List *queue;
        -:  324:    Ele  *proc;
        -:  325:    int i;   
     7860:  326:    queue = new_list();
     7860:  327:    fprintf(file_name,"P64,");
    35393:  328:    for (i=0; i<num_proc; i++)
        -:  329:    {
    27533:  330:        fprintf(file_name,"P65,");
    27533:  331:        proc = new_process(prio);
    27533:  332:        queue = append_ele(queue, proc);
        -:  333:    }
     7860:  334:    fprintf(file_name,"P66,");
     7860:  335:    prio_queue[prio] = queue;
     7860:  336:}
        -:  337:
     2620:  338:void initialize()
        -:  339:{
     2620:  340:    fprintf(file_name,"P67,");
     2620:  341:    alloc_proc_num = 0;
     2620:  342:    num_processes = 0;
     2620:  343:}
        -:  344:				
        -:  345:/* test driver */
     2650:  346:main(argc, argv)
        -:  347:int argc;
        -:  348:char *argv[];
        -:  349:{
     2650:  350:    signal(SIGSEGV, segfault_handler);
     2650:  351:    file_name=fopen("v5.txt","a+"); 
     2650:  352:    if(!file_name)
        -:  353:    {	
    #####:  354:        printf("File could not be opened! \n");
    #####:  355:        fclose(file_name);
    #####:  356:        exit(0);
        -:  357:    }
        -:  358:
        -:  359:    int command;
        -:  360:    int prio;
        -:  361:    float ratio;
        -:  362:    int status;
        -:  363:
     2650:  364:    fprintf(file_name,"\nP1,");
     2650:  365:    if (argc < (MAXPRIO+1))
        -:  366:    {
       30:  367:        fprintf(file_name,"P2,");
       30:  368:        fprintf(stdout, "incorrect usage\n");
      225:  369:        return;
        -:  370:    }
        -:  371:
     2620:  372:    initialize();
     2620:  373:    fprintf(file_name,"P3,");
    10480:  374:    for (prio=MAXPRIO; prio >= 1; prio--)
        -:  375:    {
     7860:  376:        fprintf(file_name,"P4,");
     7860:  377:	    init_prio_queue(prio, atoi(argv[prio]));
        -:  378:    }
        -:  379:
     2620:  380:    fprintf(file_name,"P5,");
     2620:  381:    for (status = fscanf(stdin, "%d", &command);
    81800:  382:	 ((status!=EOF) && status);
    79180:  383:	 status = fscanf(stdin, "%d", &command))
        -:  384:    {
    79416:  385:        fprintf(file_name,"P6,");
    79416:  386:        switch(command)
        -:  387:        {
     8024:  388:            case FINISH:
     8024:  389:                fprintf(file_name,"P7,");
     8024:  390:                finish_process();
     8024:  391:                break;
    11944:  392:            case BLOCK:
    11944:  393:                fprintf(file_name,"P8,");
    11944:  394:                block_process();
    11944:  395:                break;
    11690:  396:            case QUANTUM_EXPIRE:
    11690:  397:                fprintf(file_name,"P9,");
    11690:  398:                quantum_expire();
    11690:  399:                break;
    12344:  400:            case UNBLOCK:
    12344:  401:                fprintf(file_name,"P10,");
    12344:  402:                fscanf(stdin, "%f", &ratio);
    12344:  403:                unblock_process(ratio);
    12344:  404:                break;
    11665:  405:            case UPGRADE_PRIO:
    11665:  406:                fscanf(stdin, "%d", &prio);
    11665:  407:                fscanf(stdin, "%f", &ratio);
    11665:  408:                fprintf(file_name,"P11,");
    11665:  409:                if (prio > MAXPRIO || prio <= 0) 
        -:  410:                {
       28:  411:                    fprintf(file_name,"P12,");
       28:  412:                    fprintf(stdout, "** invalid priority\n");
       28:  413:                    return;
        -:  414:                }
        -:  415:                else
        -:  416:                {
    11637:  417:                    fprintf(file_name,"P13,");
    11637:  418:                    upgrade_process_prio(prio, ratio);
        -:  419:                }
    11596:  420:                fprintf(file_name,"P14,");
    11596:  421:                break;
    12966:  422:            case NEW_JOB:
    12966:  423:                fscanf(stdin, "%d", &prio);
    12966:  424:                fprintf(file_name,"P15,");
    12966:  425:                if (prio > MAXPRIO || prio <= 0) 
        -:  426:                {
      167:  427:                    fprintf(file_name,"P16,");
      167:  428:                    fprintf(stdout, "** invalid priority\n");
      167:  429:                    return;
        -:  430:                }
        -:  431:                else 
        -:  432:                {
    12799:  433:                    fprintf(file_name,"P17,");
    12799:  434:                    add_process(prio);
        -:  435:                }
    12799:  436:                fprintf(file_name,"P18,");
    12799:  437:                break;
    10763:  438:            case FLUSH:
    10763:  439:                fprintf(file_name,"P19,");
    10763:  440:                finish_all_processes();
    10763:  441:                break;
        -:  442:        }
        -:  443:    }
        -:  444:}
